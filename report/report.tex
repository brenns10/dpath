\documentclass{scrartcl}

\title{An XPath Query Evaluator for Filesystems}
\subtitle{EECS 433 Final Project}
\date{December 8, 2016}
\author{Stephen Brennan}

\usepackage[utf8]{inputenc}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{listings}
\usepackage{courier}
\usepackage{color}
\usepackage{hyperref}
\usepackage{qtree}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{%
  backgroundcolor=\color{white},     % background color
  basicstyle=\footnotesize\ttfamily, % monospace, small font
  breaklines=true,                   % nice line breaks
  captionpos=b,                      % put captions at bottom
  commentstyle=\color{mygreen},      % comments
  escapeinside={\%*}{*)},            % if you want to add LaTeX in code
  keywordstyle=\color{blue},         % keyword
  stringstyle=\color{mymauve},       % string
}

\begin{document}
\maketitle

\abstract

XPath is a query language designed for addressing the nodes of an XML file.
However, its power in addressing and querying tree-structured data makes it
applicable to other types of data. In this project, we describe our
implementation of one such application: DPath. DPath is a tool that allows users
to search for files with XPath expressions.

\section{Introduction}

eXtensible Markup Language (XML) is a standardized data format for sharing and
storing structured data. It bears a close resemblance to Hypertext Markup
Language (HTML), the fundamental markup underlying the web. This is because both
languages are based on Structured Generalized Markup Language, a
``meta-language'' for defining documents that contain ``markup'' \cite{sgml}.
``Markup'' can be thought of as a way to annotate data, creating structure. HTML
uses markup to describe how content should be formated. XML uses markup to
define logical structure of data. The fundamental unit of structure in XML is a
tag:

\begin{lstlisting}[language=XML]
  <Student></Student>
\end{lstlisting}

Tags may have textual attributes associated with them:

\begin{lstlisting}[language=XML]
  <Student id="1234" name="Stephen Brennan"></Student>
\end{lstlisting}

Tags can contain textual data as well as other tags:

\begin{lstlisting}[language=XML]
  <Student id="1234" name="Stephen Brennan">
    <Course id="EECS 433">Database Systems</Course>
    <Course id="MATH 303">Number Theory</Course>
    <Course id="EECS 651">Master&apos;s Thesis</Course>
  </Student>
\end{lstlisting}

XML tags, attributes, and data form a tree structure. XPath is a query language
that can be used to query and address each part of tree structures \cite{xpath}.
It achieves this using \emph{path expressions}. For example, the path expression
\texttt{//Student/Course} describes all \texttt{Course} nodes whose parent is a
\texttt{Student} node. XPath allows for even more fine-grained queries through
the use of predicates, as well as several different \emph{axes}. All of these
concepts will be discussed at length in Section~\ref{sec:xpath}.

Since XPath is a language for querying the XML tree structure, it could also be
applicable to other tree structures. One common tree structure encountered in
everyday computing is the file system. Most modern file systems are organized
into a tree where internal nodes are directories and leaf nodes are files (or
empty directories). Like XML, each file and directory has a name and attributes.
However, there are some important differences between file systems that should
be recognized.

\begin{itemize}
\item Unlike XML, a fully qualified path file path uniquely identifies a file,
  whereas a fully qualified tag path in XML may identify a whole set of nodes.
  This is because there may be several sibling tags with the same name in XML.
\item File systems may contain \emph{links} which point to other parts of the
  system, or even to a parent, creating cycles. For the purpose of this paper,
  we will ignore these links.
\end{itemize}

For this project, we have implemented a tool which evaluates queries in a
language nearly identical to XPath, called DPath. This tool runs from the
command line, accepts a query as its sole argument, and outputs one result per
line on standard output. An example query is presented below.

\begin{lstlisting}
> dpath './.[starts-with(name(.), name(..))]'
file:/home/stephen/go/src/github.com/brenns10/dpath/dpath.nn.go
file:/home/stephen/go/src/github.com/brenns10/dpath/dpath.y
file:/home/stephen/go/src/github.com/brenns10/dpath/dpath
file:/home/stephen/go/src/github.com/brenns10/dpath/dpath.nex
\end{lstlisting}

This query returns files from the DPath source directory which start with the
name of their containing directory.

The remainder of this report will be organized as follows.
Section~\ref{sec:xpath} will give a detailed description of the XPath query
language's syntax and semantics. Section~\ref{sec:dpath} will describe the
implementation of DPath. Section~\ref{sec:related} will discuss work related to
this project, and Section~\ref{sec:future} will future improvements to this
project.

\section{XPath}
\label{sec:xpath}

The XPath language is standardized by the World Wide Web Consortium (W3C), and
it is embedded within the XQuery and XSLT languages, which are also W3C
standards \cite{xpath}. In the research and development of DPath, we focused on
the 2.0 version of the XPath standard. There are several parts to the XPath
standard: syntax\cite{xpath}, semantics\cite{xpath-semantics}, data
model\cite{xpath-datamodel}, type system, operators, and built-in function
library\cite{xpath-functions}.

\subsection{Syntax}

XPath is a context-free grammar consisting of a few types of lexical tokens:
literals, names, and symbols. Numeric literals can be expressed in integer,
decimal, and scientific notations, while string literals are enclosed in single
or double quotes. The only character escaped within a string literal is the
delimiter itself. When the string delimiter occurs within the string, it is
repeated twice. For example, the string literal \texttt{'Madam I''m Adam'} is
equivalent to the string \texttt{Madam I'm Adam}.

The XPath syntax for expressing identifiers is the QName, which stands for a
``qualified name'' \cite{xml-names}. A qualified name is a pair consisting of a
``namespace name,'' which is a URI, and a ``local name''. The namespace URI is
bound to a small prefix which is then used in the QName. For instance, the
following prefixes are used throughout the XPath specification\cite{xpath}:

\begin{itemize}
\item \texttt{xs = http://www.w3.org/2001/XMLSchema}
\item \texttt{fn = http://www.w3.org/2005/xpath-functions}
\item \texttt{err = http://www.w3.org/2005/xqt-errors}
\end{itemize}

With these prefixes, a QName like \texttt{xs:integer} would refer to the local
name \texttt{integer} in the XML Schema namespace, while \texttt{fn:count} would
refer to the local name \texttt{count} within the XPath Functions namespace.
QNames may be represented without a namespace name, in which case the name is
assumed to come from the default namespace. The local part of a QName must start
with a letter or underscore (or a selection of other Unicode code points). The
remainder of the name may additionally contain hyphens, periods, or digits, but
no whitespace.

Whitespace is not significant in XPath, except in a few cases where it separates
tokens~\cite{xpath}. Otherwise, an expression such as \texttt{Student/Course} is
equivalent to \texttt{Student / Course}.

The XPath grammar is familiar to those who have implemented an expression
language. It resembles a simple expression grammar, with different non-terminals
representing each ``level'' of operator precedence. The slash operator, used to
create path expressions, has higher precedence than all of the arithmetic
operators. Most of the details of the grammar are not relevant to our
discussion, but may be found in EBNF form in the XPath
Specification~\cite{xpath}.

\subsection{Data Model}

XPath is built on some fundamental concepts that should be well understood in
order to implement it. First, the data model. XPath's data model is made up of
Items and Sequences~\cite{xpath-datamodel}. An Item is defined as any single
value, which could be an XML node, or an atomic value such as a number or
string. The types of these items are represented as QNames. There are several
types defined in the XPath specification, most of which are not relevant to our
discussion.

A Sequence contains zero or more Items, which may be of heterogeneous
types~\cite{xpath-datamodel}. Sequences are flat, meaning they may not contain
other sequences. There is no distinction between an Item and a Sequence
containing a single Item (commonly referred to as a singleton). Therefore, every
XPath expression returns a Sequence.

XPath represents XML documents with a tree of nodes (each of which is an Item)
that must be constructed prior to evaluating a path expression. This parsed
document tree includes nearly every part of the document. Elements are nodes,
but so are attributes, comments, and text enclosed within an element.

\subsection{Semantics}

When an XPath expression is evaluated, several pieces of information are known
by the engine and kept as ``context.'' The pieces of information than are known
only during evaluation of an expression are called the ``dynamic context'', and
are critical for understanding the semantics of path expressions~\cite{xpath}.
In particular, the dynamic context includes a ``context item'', which is an Item
(as defined in the data model) that is currently being processed. The context
also includes the ``context position'', which contains the index of the context
item within its containing sequence.

With an understanding of the context item, we can begin to describe the
semantics of a Path expression. A path expression can be represented as a
sequence of \emph{steps}. For instance, the path \texttt{Student/Course} has two
steps, \texttt{Student} and \texttt{Course}. A step is made up of two parts: an
\emph{axis} and a \emph{test}. The axis can be thought of as the ``direction''
in which to take a step, \emph{relative to the context object}. The test selects
certain types or names of nodes from that axis. The axis and test are
represented together with the syntax \texttt{axis::test}. When the axis is not
provided, it is assumed to be the child axis. Therefore, the \texttt{Student}
step will yield a sequence of nodes that are children of the context item and
have name \texttt{Student}. The subsequent \texttt{Child} step is applied to
each item yielded by the previous step. That is, for every item in the output of
the previous step, the context item is set to this item, and the \texttt{Child}
step is evaluated, yielding nodes which are children of the \texttt{Student}
node which are also \texttt{Child} nodes. The result of a path expression is a
Sequence that contains every result of the last step of the path.

\subsubsection{Axes}

Several axes exist on which to write paths. The most common is the
\texttt{child} axis, which we have seen. The next is the \texttt{parent} axis,
which returns the node containing the context item. Another common axis is the
\texttt{descendant} axis, which contains every item which is a child of the
context item, or a child of its children, etc. It can be thought of as the
``transitive closure'' of the \texttt{child} axis. Similarly, the
\texttt{ancestor} axis can be thought of as the ``transitive closure'' of the
\texttt{parent} axis, yielding the parent and every subsequent parent of the
context item. Finally, since the context item is not included in the
\texttt{descendant} or \texttt{ancestor} axes, there are additionally the
\texttt{descendant-or-self} and \texttt{ancestor-or-self} axes, which include
the context item. XPath additionally defines a \texttt{self} axis as well as
\texttt{following}, \texttt{following-sibling}, \texttt{preceding}, and
\texttt{preceding-sibling}, which are less relevant to our upcoming discussion
on DPath. Finally, the \texttt{attribute} axis yields attributes of the context
element.

One important notion XPath has is ``document order.'' That is, nodes can be
ordered according to when they occur in the document. All of the axes are
defined to return items with an ordering related to the document order. Forward
Axes (such as \texttt{child}, \texttt{descendant}, and \texttt{following})
return items in document order, while Reverse Axes (such as \texttt{ancestor}
and \texttt{preceding}) return items in the opposite order they occur in the
document.

\subsubsection{Tests}

There are two types of tests in XPath step expressions: a ``kind'' test and a
``name'' test. The ``kind'' test can filter items from an axis to a particular
type of item such as an element, a text node, or a comment. The syntax of
``kind'' tests looks like this: \texttt{Student/comment()}, an expression which
selects comment nodes whose parent is the \texttt{Student} item. The ``name''
test can filter items from an axis to those with a particular name. If any name
is allowable, using an asterisk will return everything from an axis. We have
already seen the syntax for these name tests.

\subsubsection{Shorthand}

A few shorthand notations are introduced in XPath to simplify commonly used
queries. We have already seen that the child axis is default, and so it need not
be qualified. Another shorthand is that \texttt{@} is short for
\texttt{attribute::}, and so a step like \texttt{@size} would select the
``size'' attribute of an element. The syntax \texttt{..} is short for
\texttt{parent::node()}, which selects the parent of the context item. Finally,
the syntax \texttt{//} is replaced by \texttt{/descendant-or-self::node()/}.

Finally, a path may be rooted or relative. A rooted path starts with a leading
slash, and indicates that the context item should be set to the root element of
the current document before evaluating the path. Otherwise, a relative path uses
the existing context item when evaluating the first step.

\subsubsection{Predicates}

Any expression returning a sequence, including full path expressions, or steps
within a path, may be filtered by one or more predicates. Each predicate is an
expression following the expression to be filtered, enclosed in square brackets.
The predicate is evaluated once for each item in the sequence. Each time, the
context item is set to an item from the sequence. If the result of the predicate
is a singleton numeric, then it is compared against the ``context position''. If
it is equal, the item is yielded by the predicate, otherwise, it is skipped. If
the result of the predicate is not a singleton numeric, it is coerced to a
Boolean, and used similarly to filter the current item.

\subsubsection{Arithmetic}

XPath includes several numeric types, and as a result it supports most common
arithmetic operations, including addition, subtraction, multiplication,
division, integer division, and the remainder operation. It also supports
comparison operators and boolean operators for complex conditions.

\subsubsection{Comparisons}

Since every XPath expression is a sequence, comparison operations have some
interesting semantics. There are two sets of comparison operators in XPath. The
first set are ``Value Comparison'' operators: \texttt{eq, ne, le, lt, ge, gt}.
They accept only singletons as their operands, and so they compare exactly one
value against exactly one other value.

The second set of comparison operators is the ``General Comparison'' operators:
\texttt{=, !=, <=, <, >=, >}. These take any sequence of operands and return
true if there exists any pair of items from the sequences that satisfy the
comparison conditions. Thus, they may be thought of as ``existential
comparisons.''

\subsubsection{Functions}

Finally, XPath includes a library of built-in functions with utility operations
that can be applied to strings, numbers, booleans, and nodes. There are several
relevant functions, which will be discussed in the following sections.

\section{DPath Implementation}
\label{sec:dpath}

With this understanding of XPath, we will now describe the implementation of
DPath, our tool and language for querying files.

\subsection{Deviations From XPath}

While the purpose of this project was to ``use XPath to query file systems,'' an
implementation of XPath which is 100\% conforming to the specification was not a
stated goal. Fully implementing a W3C standard such as XPath represents an
undertaking much too large for a single semester project. In addition, an
implementation which completely adheres to the XPath standard would likely be
too inflexible to be useful for file system querying. So, we focused on
striking a balance between the competing goals of conformance, utility, and ease
of implementation. As a result, we made some changes which compromised
conformance for ease of implementation, especially when they did not impact the
utility of DPath. Similarly, we compromised conformance for the benefit of
utility even at the cost of more implementation efforts. However, we strove to
preserve as much of the language as possible, so that using DPath would feel the
same as using XPath. Following is a list of deviations DPath makes from XPath.

\begin{itemize}
\item We discarded QNames in favor of simple identifiers (with the same
  syntactic definition as the local part of a QName). QNames have no real place
  in a file system, because no XML is actually involved.
\item We dramatically simplified the number of types. XPath includes several
  numeric types in various sizes, as well as date and time types, and any
  user-defined type from XML Schema. DPath includes a 64-bit signed integer
  type, a double precision floating point type, strings, booleans, and files.
\item We implemented only a subset of the built-in functions (listed later in
  this section).
\item We did not implement the \texttt{self}, \texttt{preceding},
  \texttt{preceding-sibling}, \texttt{following}, and \texttt{following-sibling}
  axes. These do not have obvious places in directory querying.
\item Since file systems have no equivalent to document ordering, we discarded
  the distinction between forward and reverse axes, and do not provide any
  guarantee on what order the axes yield items. As a further result of this,
  without deterministic item ordering, there is no reason to use predicates for
  numeric indexing. Therefore, all predicate expressions are cast to booleans
  rather than the semantics described in the previous section.
\item Since not all file names conform to the limitations of the QName local
  identifier syntax, we introduced a shorthand syntax, \texttt{\#"literal"}
  which can be used wherever a name test is expected.
\item The only kind tests are \texttt{file()} and \texttt{dir()}.
\item Some lesser-known parts of XPath were not implemented. We judged that the
  utility they provided to DPath was not worth their implementation effort.
  These parts include: for-return expressions, if-conditionals, quantifiers, and
  type casting expressions, and the union and intersection operators.
\end{itemize}

Despite this rather daunting list of omissions and deviations, the resulting
DPath language retains the necessary flavor and power of XPath for querying
directories, and was sufficiently simple to be implemented by a single person in
a single semester.

\subsection{Parsing}

DPath is implemented in the Go programming language. This is a relatively new
language which was released open-source by Google in November of
2009~\cite{golang}.

The scanner is implemented using Nex~\cite{nex}, a Go tool inspired and heavily
based on the earlier Unix tool Lex~\cite{lex}. This tool takes as input a source
file (\texttt{dpath.nex}) containing several regular expressions, each one
defining a token. It produces as output a lexical analyzer in Go which is
capable of parsing a stream of these tokens and returning them sequentially.

The parser is implemented using Go's built-in implementation of the Yacc
tool~\cite{yacc}. This tool takes as input a source file \texttt{dpath.y}
containing a grammar, where each production specifies an action to be taken, in
the form of Go code. It produces as output an LR(1) parser in Go.

The generated lexer and parser are accessed from the rest of the code via the
\texttt{Parse()} function, which takes an input stream and returns either a
parse tree or an error.

The returned parse tree is an ``interface'' which supports printing (for
diagnostics) and evaluation. The \texttt{ParseTree} interface has an
implementation for many different productions in the grammar. For instance, it
has a \texttt{BinopTree} implementation which represents a binary operator and
contains a string operator along with two \texttt{ParseTree} operands.

Code evaluation is therefore distributed across \texttt{Evaluate()} methods of
the parse tree objects, which may all be found in \texttt{tree.go}.

\subsection{Data Model}

Internally, the DPath data model mirrors XPath's specification. An \texttt{Item}
interface is defined in \texttt{item.go}. \texttt{Item} has an implementation
for each of DPath's types. Its implementations must support comparison as well
as the basic operators.

Similarly, a \texttt{Sequence} interface is defined in \texttt{sequence.go}
which supports two major operations: \texttt{Value()}, which returns the current
value in the sequence, and \texttt{Next()}, which advances the sequence forward
by one. Several implementations of this interface exist. Some, like the
\texttt{WrapperSequence}, simply wrap arrays of \texttt{Items}. Others, like
\texttt{DescendantSequence} and \texttt{RangeSequence}, dynamically produce a
steady stream of items. Still others, like the \texttt{ExpressionFilter}, wrap
source sequences and filter out those which don't match a condition. By creating
and composing sequences, the evaluation functions can produce complex sequences
that produce desired query results.

Finally, an important part of the data model is the \texttt{Axis} interface.
This interface requires two methods: \texttt{GetByName()}, which helps implement
name filters in step expressions, and \texttt{Iterate()}, which returns a
\texttt{Sequence} and helps implement most of the step expressions that do not
involve a name filter.

\subsection{Example Queries}

Rather than listing and explaining each the implemented axes, sequences, and
items, it would be most illustrative to give a few sample queries, walking
through the evaluation process for each of them. While this is not exhaustive,
it is more useful for understanding the inner workings of the query engine.

\subsubsection{A Simple Example}

First, let us consider the following query:

\begin{center}
  \ttfamily
  (1 to 10)[. mod 2 eq 0]
\end{center}

This query involves no files or axes. Instead, it involves a little-known
feature of XPath called ``range expressions,'' which are numeric expressions
that produce lists of numerics. \texttt{(1 to 10)} produces a list of the
integers 1 through 10, while the predicate afterward filters it to those which
are divisible by 2. Thus, the output of this expression should be the sequence
\texttt{2, 4, 6, 8, 10}.

First, the parser produces the following tree:

\Tree [.FilteredSequenceTree
        [.BinopTree [.LiteralTree 1 ]
                    to
                    [.LiteralTree 10 ]]
        [.BinopTree [.BinopTree [.. ]
                                mod
                                [.LiteralTree 2 ]]
                    eq
                    [.LiteralTree 0 ]]
]

Next, \texttt{Evaluate()} is called on the \texttt{FilteredSequenceTree}. This
function first evaluates \texttt{BinopTree} on the left hand side, which returns
a \texttt{RangeSequence}. The \texttt{RangeSequence} dynamically creates a list
of numbers from 1 to 10, computing the next one each time \texttt{Next()} is
called. This \texttt{RangeSequence} is returned back to the
\texttt{FilteredSequenceTree}, which uses it to create an
\texttt{ExpressionFilter}. This is another sequence type, which takes a source
sequence and a list of \texttt{ParseTrees} which are predicates. For each item
in the source sequence, it sets the context object to that item, evaluates each
predicate, and returns the item if all predicates are true.

So, an \texttt{ExpressionFilter} is returned from the \texttt{Evaluate()}
function. At this point, the main driver begins calling \texttt{Next()} on the
returned sequence and printing out the results. This causes the
\texttt{ExpressionFilter} to call \texttt{Next()} on the \texttt{RangeSequence},
and then filter the results until it finds an item satisfying all predicates,
which it returns. The first such item is the integer 2, then 4, 6, 8, and 10, at
which point the \texttt{RangeSequence} runs out.

One important thing to note about this entire process is that not very much
computation occurs when \texttt{Evaluate()} is called. Instead, sequences are
constructed that dynamically produce and filter items as they are iterated over.
This is important, because implementations which load an entire sequence of
items into memory would fail miserably on large queries, like those involving
\texttt{descendant-or-self}.

\subsubsection{A Filesystem Query}

Next, let us consider the following query.

\begin{center}
  \ttfamily
  .//*
\end{center}

This query returns all files that are descendants of the current directory. The
following is the effective parse tree:

\Tree[.PathTree .
                [.AxisTree \texttt{descendant-or-self}
                           [.NameTree * ]]
                [.NameTree * ]
]

In order to evaluate this query, an entire system of sequences are created and
combined. The following tree represents the structure of the system of
sequences:

\Tree[.PathSequence [.PathSequence [.WrapperSequence(.) ]
                                   [.ConcatenateSequence
                                       [.WrapperSequence(.) ]
                                       [.DescendantSequence ]]]
                    [.WrapperSequence(*) ]
]

The most important sequence to understand is the \texttt{PathSequence}. This
sequence is used to evaluate any path that has multiple steps. It takes as input
a source sequence, which is the result of evaluating the previous step. It also
takes as input the \texttt{ParseTree} of the current step. For each item from
the input sequence, it sets the current context to that item and evaluates the
parse tree on that item. It then yields items from the resulting sequence. When
that sequence runs out, it requests a new item from the source, evaluates the
expression again, and continues until no more items are yielded from the source
sequence.

We see that the first sequence created (at the lower left) is a
\texttt{WrapperSequence}, which wraps a list of exactly one item, the context
item. In this case, the context item is the current directory. This item is
passed into the parent \texttt{PathSequence}, which evaluates the implicit
\texttt{descendant-or-self::*} expression on that context item. This calls
\texttt{Iterate()} on the \texttt{DescendantOrSelfAxis}. Since the
\texttt{descendant-or-self} axis is a combination of the current context item
and its descendants, it simply concatenates a sequence containing the current
context item with a special sequence called \texttt{DescendantSequence}.

The \texttt{DescendantSequence} implements a depth first search. It operates by
first finding all the children of the current context item (using the
\texttt{readdir} system call). As it yields these children, it checks them one
by one to see if they are directories. If they are, they are added to a stack,
to be expanded later. Once the sequence of children is exhausted,
\texttt{DescendantSequence} pops a directory off the stack, finds its children,
and repeats this until its stack is empty.

Finally, this sequence is passed to the outer \texttt{PathSequence}, which
evaluates the \texttt{*} step for each item returned by it. This involves
calling \texttt{Iterate()} on the default axis, \texttt{ChildAxis}. This simply
calls \texttt{readdir} and returns a \texttt{WrapperSequence} of children of the
context item (or an empty sequence when the context item is a file).

It's interesting to note that the output of the first two steps is all
descendants of the current directory, \emph{including the current directory}.
But when this sequence is passed into the last step, all the files are filtered
(since they have no children), and each directory is iterated over again! The
only observable effect of this is that the current directory is not included in
the final output, whereas it would have been included if the query were simply
the first two steps (i.e. \texttt{./descendant-or-self::*}). In fact, it makes
sense that a path containing the step \texttt{descendant-or-self::*} followed by
\texttt{child::*} could be simplified to \texttt{descendant::*}, and a simple
optimizer could certainly take advantage of this fact. However, DPath includes
no query optimization, always using the na\"ive approach that exactly mirrors
the semantics of a query.

\subsection{Built-in Functions and Attributes}

DPath has XPath's powerful path syntax for referencing items in a tree structure
using their parent, child, ancestor, and descendant relationships. However, this
would not be useful without the ability to apply more conditions on these
relationships. As such, DPath implements a substantial subset of XPath's
built-in functions, especially focusing on string operations. This section
provides a brief listing of these functions. More documentation is available in
the \texttt{SYNTAX.md} file included in the DPath source directory.

\begin{itemize}
\item \texttt{string()}, \texttt{concat()}, and \texttt{substring()} for
  converting and concatenating, and taking substrings of strings.
\item \texttt{string-length()} for counting characters in strings.
\item \texttt{starts-with()}, \texttt{ends-with()}, and \texttt{contains()} for
  checking conditions on strings.
\item \texttt{matches()} for matching strings against regular expressions.
\item \texttt{count()} for finding the length of sequences, along with
  \texttt{empty()} and \texttt{exists()} for checking special cases of these
  lengths.
\item \texttt{not()} for inverting booleans and \texttt{boolean()} for
  converting anything to a boolean.
\item \texttt{path()} for returning a file's full path, and \texttt{name()} for
  returning its base name.
\item \texttt{round()} for rounding a number
\end{itemize}

In addition, the XPath attribute axis has an analog in DPath. The DPath
attribute axis contains only one item, the size of the context item. For
instance, \texttt{y.go/@size} returns the integer 21474, the size of the file in
bytes.

\section{Related Work}
\label{sec:related}

A discussion of file system querying would not be complete without mentioning
the GNU Findutils~\cite{find}. This is a collection of file search programs
(\texttt{find}, \texttt{locate}, \texttt{xargs}, and \texttt{updatedb}) which
are distributed as standard on many Linux and other Unix-based computers. The
\texttt{find} program serves a similar purpose to DPath, but instead of
evaluating XPath queries, it uses a system of command-line flags to specify
search criteria.

GNU \texttt{find} is capable of searching based on conditions on the file path
and size (both of which DPath supports), as well as modes, owner, permissions,
and access times (which DPath does not support). It allows the user to ``prune''
the search tree by specifying a max recursion depth, or specifying folders not
to descend into. DPath is capable of these restrictions, but they are not
evaluated efficiently, since they must be expressed as predicates on the
sequence of items which is already being traversed.

One critical feature that GNU Findutils has is the capability to create a
filesystem index and query that, rather than searching the file system each time
a query runs. This functionality is mostly used for fast name searches, since
file names change much less frequently than other metadata. This feature is
important because, during file system searches, the limiting factor is
frequently not the speed of the query evaluator, but rather the number of times
the disk is accessed for file system calls such as \texttt{readdir()} and
\texttt{stat()}. File system indices can reduce or eliminate these system calls,
but require regular updates (similar to database indices).

Another important thing to note is that DPath is not a novel invention. We were
able to find at least one other implementation of XPath on the file system on
the Internet~\cite{other}. In fact, this implementation was integrated with the
GNU \texttt{find} tool, although it required extensive modifications in order to
run. This implementation exposed more file attributes to the system and included
a maximum depth option, and it relied on a pre-made XPath library rather than
implementing its own.

\section{Future Work}
\label{sec:future}

There are several opportunities for improving DPath in the future. First, it
would be beneficial to include more filesystem metadata in the attribute axis of
files. However, Go's built-in operating system interface did not provide such
details, in an attempt at platform independence.

Also, it would be very useful to include some forms of query optimization. As
mentioned earlier, queries such as \texttt{//*} are evaluated inefficiently with
a naive query evaluator, when they could be optimized to a query such as
\texttt{/descendant::node()}.

\section{Conclusion}

In this paper, we have described the implementation of DPath, an implementation
of XPath for file system querying. We have found the development to be
informative and the end result to be a useful tool. The complete source code to
DPath, along with setup instructions and other documentation, may be found at:
\url{https://github.com/brenns10/dpath}

\bibliographystyle{ieeetr}
\bibliography{report}
\end{document}
