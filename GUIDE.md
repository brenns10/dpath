# Guide to the DPath Code

## Lexical Analyzer

The lexical analyzer of DPath is built using a tool called [Nex][]. This is a Go
version of the Unix tool Lex. It's not quite identical to Lex, but it's close.
The main difference is in syntax---patterns are surrounded by slashes, and the
list of patterns is terminated by an empty pattern. The remainder of the file is
code that is unmodified.

The file [dpath.nex]() is the input to Nex. Nex transforms it into a lexical
analyzer in a file named `dpath.nn.go`. The lexer can be created with
`NewLexer()`. The lexer is directly used by the parser.

Tokens are declared for every symbol that is used in the grammar. Some important
definitions include the definitions for literals and identifiers (identifiers
are referred to as the token QNAME).

```
/("[^"]*")+|('[^']*')+/
{ lval.str = yylex.Text(); return STRING_LITERAL }
/[0-9]+/
{ lval.str = yylex.Text(); return INTEGER_LITERAL }
/\.[0-9]+|[0-9]+\.[0-9]*/
{ lval.str = yylex.Text(); return DECIMAL_LITERAL }
/(\.[0-9]+|[0-9]+\.[0-9]*)[Ee][+-]?[0-9]+/
{ lval.str = yylex.Text(); return DOUBLE_LITERAL }

...

/[a-zA-Z_][a-zA-Z0-9_.-]*/
{ lval.str = yylex.Text(); return QNAME }
```

## Parser

The parser is generated by the standard Go version of the Unix parser generator
Yacc. The input file is [dpath.y](), which is transformed to a Go file named
`y.go`. It can be used by calling `yyParse()` with a lexer object.

The [dpath.y]() file starts with a "union" declaration that declares the
different types of values that can be associated with a token. The `%token` and
`%type` declarations inform Yacc which parts of the union are used by each token
and non-terminal symbol.

The grammar follows these declarations, and each production has a block of code
that assists in constructing a parse tree (the parse tree structures are found
in [tree.go]()).

The grammar is a modified version of the one you'll find in the XPath
2.0 [specification][]. It has several features stripped from it. For the most
part, the grammar resembles a classic compilers-class expression grammar, with a
non terminal symbol for each level of operator precedence. The major feature
difference is that a "value" in this grammar is a "path expression", which
contains several "steps". Or it could simply be a literal, or a sub-expression.

## Evaluation

The program starts from [main.go](), and it parses the first command line
argument as a DPath expression. The parser returns a `ParseTree`, which has an
`Evaluate` method. Expressions must be evaluated within a context, so the main
file creates this context using the `DefaultContext()` function (found
in [axis.go]()). The context contains a few critical things:

- Context Item: this is the item which `.` refers to, and it's where relative
  paths start from. In XML, it may be a document node, but in DPath, it's
  usually a file or directory. It starts as the process's current directory and
  updates during execution depending on (you guessed it) context.
- Current Axis: axes are "directions" that you can step through in a path.
  Conceptually an axis must be able to take a context item and give a bunch more
  items "in the direction of that axis". For instance, the `child` axis (which
  is default) will give the contents of a directory. The axis we're working on
  may change as we evaluate the expression.
- A namespace of built in functions.

## Data Model

Just like XPath, every expression in DPath evaluates to a sequence, which
contains zero or more items. Items can be files, integers, doubles, booleans,
and strings.

The Sequence abstraction allows for code to be combined in powerful ways within
the query engine. There are Sequence implementations for combining sequences,
filtering them, and generating them. For instance, paths are evaluated by
chaining together sequences, where each one takes the output of the previous
step and uses it as the "context item" for the current step of the path.
Graphically, this could look something like this:

```
Expression; /blah//blah
Path Elements: /, blah, descendant-or-self::*, blah
Sequence Diagram:

+------+      +--------+      +----------+      +--------+
| Root | ---> | "blah" | ---> | D-O-S::* | ---> | "blah" |
+------+      +--------+      +----------+      +--------+
```

In the diagram above, "Root" is a sequence which returns a single item, the root
directory of the filesystem. "blah" is a sequence which will take the root
directory from that sequence, set it as its "context item", and search for items
named "blah" along the current axis. In other words, it looks for a file or
directory named "blah" that is a child of the root directory.

Next, the `descendant-or-self::*` node (thankfully we have the shorthand `//`)
will take each output of the previous sequence and output all descendants (i.e.
files and folders within that directory, *including subdirectories*). Finally,
the second "blah" node does the same as the first "blah" node.

The whole expression would match things like this:

```
/blah/foo/bar/blah
/blah/blah/foo/bar/blah
/blah/blah
```

The actual number of sequences used in evaluating the above expression is a bit
more complicated than the diagram says (mainly for the descendant or self part).
The code is the best place to go to learn about how these things go together.
Sequences are in [sequence.go]() and you can find the axis definitions
in [axis.go](). Path expressions in particular use the `PathSequence` and the
descendant-or-self axis from above is implemented by using `ConcatenateSequence`
to combine a `WrapperSequence` with a `PathSequence` wrapping a
`DescendantSequence`... it gets a bit complicated!

## File Listing

- `dpath.nex` - lexical analyzer source, which generates `dpath.nn.go`
- `dpath.y` - parser source, which generates `y.go`
- `tree.go` - parse structures, which contains the basic evaluation functions
- `item.go` - contains declarations for each type of item, and the bulk of the
  code related to evaluating operators lives here
- `sequence.go` - contains the interface and implementations of the sequence.
  You'll find some of the most important code for the actual DPath querying here
- `axis.go` - contains interface and implementation of axes. The rest of the
  exciting code is found here
- `lib.go` - contains built-in functions
- `util.go`, `error.go` - contains utilities and errors (shockingly)
- `main.go` - the main command line driver program

[nex]: http://crypto.stanford.edu/~blynn/nex/
[specification]: https://www.w3.org/TR/xpath20/#nt-bnf
